
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tui: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/devflowinc/uzi/pkg/tui/app.go (32.1%)</option>
				
				<option value="file1">github.com/devflowinc/uzi/pkg/tui/claude_squad_example.go (0.0%)</option>
				
				<option value="file2">github.com/devflowinc/uzi/pkg/tui/example_usage.go (0.0%)</option>
				
				<option value="file3">github.com/devflowinc/uzi/pkg/tui/keys.go (100.0%)</option>
				
				<option value="file4">github.com/devflowinc/uzi/pkg/tui/list.go (75.0%)</option>
				
				<option value="file5">github.com/devflowinc/uzi/pkg/tui/styles.go (0.0%)</option>
				
				<option value="file6">github.com/devflowinc/uzi/pkg/tui/tmux.go (0.6%)</option>
				
				<option value="file7">github.com/devflowinc/uzi/pkg/tui/uzi_interface.go (29.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/bubbles/key"
)

// RefreshMsg is sent by the ticker to refresh sessions without clearing screen
type RefreshMsg struct{}

// TickMsg wraps time.Time for ticker messages
type TickMsg time.Time

// App represents the main TUI application
type App struct {
        uzi      UziInterface
        list     *ListModel
        keys     KeyMap
        ticker   *time.Ticker
        width    int
        height   int
        loading  bool
}

// NewApp creates a new TUI application instance
func NewApp(uzi UziInterface) *App <span class="cov8" title="1">{
        // Initialize the list view
        list := NewListModel(80, 24) // Default size, will be updated on first render
        
        return &amp;App{
                uzi:     uzi,
                list:    &amp;list,
                keys:    DefaultKeyMap(),
                ticker:  nil, // Will be created in Init
                loading: true,
        }
}</span>

// tickEvery returns a command that sends TickMsg every duration
func tickEvery(d time.Duration) tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(d, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return TickMsg(t)
        }</span>)
}

// refreshSessions returns a command that fetches sessions and sends RefreshMsg
func (a *App) refreshSessions() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Load sessions via UziInterface
                sessions, err := a.uzi.GetSessions()
                if err != nil </span><span class="cov0" title="0">{
                        // For now, just return the refresh message even on error
                        // In a production app, you might want to handle errors differently
                        return RefreshMsg{}
                }</span>
                
                // Update the list with new sessions
                <span class="cov0" title="0">a.list.LoadSessions(sessions)
                a.loading = false
                
                return RefreshMsg{}</span>
        }
}

// Init implements tea.Model interface
func (a *App) Init() tea.Cmd <span class="cov8" title="1">{
        // Start the 2-second ticker and initial session load
        return tea.Batch(
                a.refreshSessions(), // Load sessions immediately
                tickEvery(2*time.Second), // Start ticker for smooth updates
        )
}</span>

// Update implements tea.Model interface
func (a *App) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                // Handle key events
                switch </span>{
                case key.Matches(msg, a.keys.Quit):<span class="cov0" title="0">
                        return a, tea.Quit</span>
                        
                case key.Matches(msg, a.keys.Refresh):<span class="cov0" title="0">
                        // Manual refresh
                        a.loading = true
                        return a, a.refreshSessions()</span>
                        
                case key.Matches(msg, a.keys.Enter):<span class="cov0" title="0">
                        // Handle session selection/attachment
                        if selected := a.list.SelectedSession(); selected != nil </span><span class="cov0" title="0">{
                                // Attach to the selected session
                                return a, func() tea.Msg </span><span class="cov0" title="0">{
                                        err := a.uzi.AttachToSession(selected.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                // Handle error - for now just continue
                                                return nil
                                        }</span>
                                        <span class="cov0" title="0">return tea.Quit</span> // Exit TUI after attaching
                                }
                        }
                        
                case key.Matches(msg, a.keys.Kill):<span class="cov8" title="1">
                        // Handle agent kill command
                        if selected := a.list.SelectedSession(); selected != nil </span><span class="cov8" title="1">{
                                // Kill the selected agent session
                                return a, func() tea.Msg </span><span class="cov8" title="1">{
                                        err := a.uzi.KillSession(selected.Name)
                                        if err != nil </span><span class="cov8" title="1">{
                                                // Handle error - for now just continue
                                                return nil
                                        }</span>
                                        // Refresh sessions after kill
                                        <span class="cov8" title="1">return RefreshMsg{}</span>
                                }
                        }
                }
                
                // Delegate other key events to the list
                <span class="cov8" title="1">var cmd tea.Cmd
                model, cmd := a.list.Update(msg)
                if listModel, ok := model.(ListModel); ok </span><span class="cov8" title="1">{
                        *a.list = listModel
                }</span>
                <span class="cov8" title="1">return a, cmd</span>
                
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                // Update dimensions
                a.width = msg.Width
                a.height = msg.Height
                
                // Update list size (leave space for potential status bar)
                a.list.SetSize(msg.Width, msg.Height-2)
                
                // Delegate to list for its own size handling
                var cmd tea.Cmd
                model, cmd := a.list.Update(msg)
                if listModel, ok := model.(ListModel); ok </span><span class="cov0" title="0">{
                        *a.list = listModel
                }</span>
                <span class="cov0" title="0">return a, cmd</span>
                
        case TickMsg:<span class="cov0" title="0">
                // Ticker fired - refresh sessions smoothly without clearing screen
                return a, tea.Batch(
                        a.refreshSessions(), // Refresh session data
                        tickEvery(2*time.Second), // Schedule next tick
                )</span>
                
        case RefreshMsg:<span class="cov0" title="0">
                // Sessions have been refreshed - no action needed
                // The list has already been updated in refreshSessions()
                return a, nil</span>
                
        default:<span class="cov0" title="0">
                // Delegate other messages to the list
                var cmd tea.Cmd
                model, cmd := a.list.Update(msg)
                if listModel, ok := model.(ListModel); ok </span><span class="cov0" title="0">{
                        *a.list = listModel
                }</span>
                <span class="cov0" title="0">return a, cmd</span>
        }
}

// View implements tea.Model interface - delegates to list view
func (a *App) View() string <span class="cov0" title="0">{
        // If we don't have proper dimensions yet, return a simple message
        if a.width == 0 || a.height == 0 </span><span class="cov0" title="0">{
                return "Loading..."
        }</span>
        
        // Delegate to the list view for rendering
        <span class="cov0" title="0">listView := a.list.View()
        
        // Add a subtle status line if loading
        if a.loading </span><span class="cov0" title="0">{
                statusLine := ClaudeSquadMutedStyle.Render("Refreshing sessions...")
                return listView + "\n" + statusLine
        }</span>
        
        <span class="cov0" title="0">return listView</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "fmt"
        "log"
)

// ExampleClaudeSquadListView demonstrates the Claude Squad styled list view
// with the LoadSessions function for rendering sessions with agent names,
// status icons, diff stats, and dev URLs.
func ExampleClaudeSquadListView() <span class="cov0" title="0">{
        // Sample session data similar to what would come from Uzi
        sessions := []SessionInfo{
                {
                        Name:        "web-dev-session",
                        AgentName:   "claude-3.5-sonnet",
                        Model:       "claude-3.5-sonnet",
                        Status:      "running",
                        Prompt:      "Create a React application with TypeScript and Tailwind CSS",
                        Insertions:  127,
                        Deletions:   34,
                        Port:        3000,
                },
                {
                        Name:        "api-dev-session",
                        AgentName:   "gpt-4",
                        Model:       "gpt-4",
                        Status:      "attached",
                        Prompt:      "Build a REST API with authentication and database integration",
                        Insertions:  89,
                        Deletions:   12,
                        Port:        8080,
                },
                {
                        Name:        "testing-session",
                        AgentName:   "claude-3.5-haiku",
                        Model:       "claude-3.5-haiku",
                        Status:      "ready",
                        Prompt:      "Write comprehensive unit tests for the user service",
                        Insertions:  45,
                        Deletions:   7,
                        Port:        0,
                },
                {
                        Name:        "refactor-session",
                        AgentName:   "gpt-4o",
                        Model:       "gpt-4o",
                        Status:      "inactive",
                        Prompt:      "Refactor the legacy codebase to improve performance and maintainability",
                        Insertions:  0,
                        Deletions:   0,
                        Port:        0,
                },
        }

        // Create a list model with Claude Squad styling
        listModel := NewListModel(100, 20)
        
        // Load sessions using the LoadSessions function
        // This renders each row with agent name, status icon, diff stats, and dev URL
        listModel.LoadSessions(sessions)

        fmt.Println("=== Claude Squad Styled Session List ===")
        fmt.Println("Each row shows: [status_icon] agent_name (model)")
        fmt.Println("                status | diff_stats | dev_url | prompt...")
        fmt.Println()

        // Demonstrate what each session would look like in the TUI
        for i, session := range sessions </span><span class="cov0" title="0">{
                sessionItem := NewSessionListItem(session)
                
                fmt.Printf("%d. %s\n", i+1, sessionItem.Title())
                fmt.Printf("   %s\n", sessionItem.Description())
                fmt.Println()
        }</span>

        // Show how the list model can be used to get selected session
        <span class="cov0" title="0">fmt.Println("List model features:")
        fmt.Printf("- Total sessions loaded: %d\n", len(listModel.list.Items()))
        fmt.Printf("- List dimensions: %dx%d\n", listModel.width, listModel.height)
        
        // In a real TUI application, you would call listModel.View() to render
        // the list and handle user interactions through the Update method
        
        fmt.Println("\nColor scheme (Claude Squad):")
        fmt.Printf("- Primary text: %s (white)\n", ClaudeSquadPrimary)
        fmt.Printf("- Accent color: %s (Claude Squad green)\n", ClaudeSquadAccent)
        fmt.Printf("- Background: %s (deep black)\n", ClaudeSquadDark)
        fmt.Printf("- Muted text: %s (gray)\n", ClaudeSquadMuted)</span>
}

// RunClaudeSquadExample runs the Claude Squad list view example
func RunClaudeSquadExample() <span class="cov0" title="0">{
        fmt.Println("Running Claude Squad list view example...")
        
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("Error in Claude Squad example: %v", r)
                }</span>
        }()
        
        <span class="cov0" title="0">ExampleClaudeSquadListView()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "fmt"
        "log"
        "strings"

        "github.com/charmbracelet/bubbles/list"
)

// ExampleTmuxUsage demonstrates how the TUI list view can use tmux discovery
// to highlight attached/active sessions
func ExampleTmuxUsage() error <span class="cov0" title="0">{
        // Create Uzi CLI interface with tmux discovery
        uziCLI := NewUziCLI()
        
        // Get sessions with tmux attachment information
        sessions, tmuxMapping, err := uziCLI.GetSessionsWithTmuxInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sessions with tmux info: %w", err)
        }</span>
        
        // Convert sessions to list items
        <span class="cov0" title="0">var listItems []list.Item
        for _, session := range sessions </span><span class="cov0" title="0">{
                // Note: tmuxMapping available but not used in simplified API
                _ = tmuxMapping // Ignore for now
                
                // Create session list item with Claude Squad styling
                sessionItem := NewSessionListItem(session)
                listItems = append(listItems, sessionItem)
        }</span>
        
        // Create list model with the enhanced items
        <span class="cov0" title="0">listModel := NewListModel(80, 24)
        
        // Print example of what the TUI would display
        fmt.Println("=== Uzi TUI Session List (with tmux highlighting) ===")
        
        for i, item := range listItems </span><span class="cov0" title="0">{
                if sessionItem, ok := item.(SessionListItem); ok </span><span class="cov0" title="0">{
                        // Use the formatted status icon from the session item
                        status := sessionItem.formatStatusIcon(sessionItem.session.Status)
                        
                        fmt.Printf("%d. %s %s\n", 
                                i+1, 
                                status,
                                sessionItem.Title())
                        fmt.Printf("   %s\n", sessionItem.Description())
                }</span>
        }
        
        // Show activity summary
        <span class="cov0" title="0">attachedCount, err := uziCLI.GetAttachedSessionCount()
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("\nAttached sessions: %d\n", attachedCount)
        }</span>
        
        // Show sessions grouped by activity
        <span class="cov0" title="0">sessionsByActivity, err := uziCLI.GetTmuxSessionsByActivity()
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("\nSession Activity Summary:\n")
                for activity, sessions := range sessionsByActivity </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: %d sessions\n", activity, len(sessions))
                }</span>
        }
        
        <span class="cov0" title="0">_ = listModel // Would be used in actual TUI
        
        return nil</span>
}

// ExampleTmuxDiscoveryOnly demonstrates using just the tmux discovery helper
func ExampleTmuxDiscoveryOnly() error <span class="cov0" title="0">{
        // Create tmux discovery helper
        tmuxDiscovery := NewTmuxDiscovery()
        
        // Get all tmux sessions
        allSessions, err := tmuxDiscovery.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get tmux sessions: %w", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("=== All Tmux Sessions ===")
        for name, session := range allSessions </span><span class="cov0" title="0">{
                status := "‚óã"
                if session.Attached </span><span class="cov0" title="0">{
                        status = "üîó"
                }</span> else<span class="cov0" title="0"> if session.Activity == "active" </span><span class="cov0" title="0">{
                        status = "‚óè"
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("%s %s (%d windows, %d panes) - %s\n", 
                        status, name, session.Windows, session.Panes, session.Activity)
                
                if len(session.WindowNames) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Windows: %v\n", session.WindowNames)
                }</span>
        }
        
        // Get only Uzi sessions
        <span class="cov0" title="0">uziSessions, err := tmuxDiscovery.GetUziSessions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get Uzi sessions: %w", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("\n=== Uzi Sessions Only ===\n")
        for name, session := range uziSessions </span><span class="cov0" title="0">{
                fmt.Printf("- %s (attached: %v, activity: %s)\n", 
                        name, session.Attached, session.Activity)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// RunExamples runs both examples to demonstrate the functionality
func RunExamples() <span class="cov0" title="0">{
        fmt.Println("Running tmux discovery examples...")
        
        if err := ExampleTmuxDiscoveryOnly(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error in tmux discovery example: %v", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("\n" + strings.Repeat("=", 50) + "\n")
        
        if err := ExampleTmuxUsage(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error in TUI usage example: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "github.com/charmbracelet/bubbles/key"
        tea "github.com/charmbracelet/bubbletea"
)

// KeyMap defines the key bindings for the TUI
type KeyMap struct {
        // Navigation keys
        Up    key.Binding
        Down  key.Binding
        Left  key.Binding
        Right key.Binding
        
        // Action keys
        Enter  key.Binding
        Escape key.Binding
        
        // Application actions
        Help    key.Binding
        Quit    key.Binding
        Refresh key.Binding
        Kill    key.Binding
        // List specific keys
        Filter key.Binding
        Clear  key.Binding
}

// DefaultKeyMap returns the default key bindings
func DefaultKeyMap() KeyMap <span class="cov8" title="1">{
        return KeyMap{
                // Navigation
                Up: key.NewBinding(
                        key.WithKeys("up"),
                        key.WithHelp("‚Üë", "move up"),
                ),
                Down: key.NewBinding(
                        key.WithKeys("down", "j"),
                        key.WithHelp("‚Üì/j", "move down"),
                ),
                Left: key.NewBinding(
                        key.WithKeys("left", "h"),
                        key.WithHelp("‚Üê/h", "move left"),
                ),
                Right: key.NewBinding(
                        key.WithKeys("right", "l"),
                        key.WithHelp("‚Üí/l", "move right"),
                ),
                
                // Actions
                Enter: key.NewBinding(
                        key.WithKeys("enter"),
                        key.WithHelp("enter", "select"),
                ),
                Escape: key.NewBinding(
                        key.WithKeys("esc"),
                        key.WithHelp("esc", "back"),
                ),
                
                // Application
                Quit: key.NewBinding(
                        key.WithKeys("q", "ctrl+c"),
                        key.WithHelp("q", "quit"),
                ),
                Help: key.NewBinding(
                        key.WithKeys("?"),
                        key.WithHelp("?", "help"),
                ),
                Refresh: key.NewBinding(
                        key.WithKeys("r"),
                        key.WithHelp("r", "refresh"),
                ),
                Kill: key.NewBinding(
                        key.WithKeys("k"),
                        key.WithHelp("k", "kill agent"),
                ),
                
                // List specific
                Filter: key.NewBinding(
                        key.WithKeys("/"),
                        key.WithHelp("/", "filter"),
                ),
                Clear: key.NewBinding(
                        key.WithKeys("c"),
                        key.WithHelp("c", "clear filter"),
                ),
        }
}</span>

// ShortHelp returns keybindings to be shown in the mini help view
func (k KeyMap) ShortHelp() []key.Binding <span class="cov8" title="1">{
        return []key.Binding{k.Help, k.Quit}
}</span>

// FullHelp returns keybindings for the expanded help view
func (k KeyMap) FullHelp() [][]key.Binding <span class="cov8" title="1">{
        return [][]key.Binding{
                {k.Up, k.Down, k.Left, k.Right}, // Navigation
                {k.Enter, k.Escape, k.Refresh, k.Kill},  // Actions
                {k.Filter, k.Clear, k.Help, k.Quit}, // Application
        }
}</span>

// CursorState represents the cursor position in a list
type CursorState struct {
        index   int // Current cursor position
        maxSize int // Maximum size of the list
}

// NewCursorState creates a new cursor state
func NewCursorState() *CursorState <span class="cov8" title="1">{
        return &amp;CursorState{
                index:   0,
                maxSize: 0,
        }
}</span>

// Index returns the current cursor index
func (c *CursorState) Index() int <span class="cov8" title="1">{
        return c.index
}</span>

// SetMaxSize sets the maximum size for the cursor
func (c *CursorState) SetMaxSize(size int) <span class="cov8" title="1">{
        c.maxSize = size
        if c.index &gt;= size &amp;&amp; size &gt; 0 </span><span class="cov8" title="1">{
                c.index = size - 1
        }</span>
}

// MoveUp moves the cursor up by one position
func (c *CursorState) MoveUp() <span class="cov8" title="1">{
        if c.index &gt; 0 </span><span class="cov8" title="1">{
                c.index--
        }</span>
}

// MoveDown moves the cursor down by one position
func (c *CursorState) MoveDown() <span class="cov8" title="1">{
        if c.maxSize &gt; 0 &amp;&amp; c.index &lt; c.maxSize-1 </span><span class="cov8" title="1">{
                c.index++
        }</span>
}

// Reset resets the cursor to the top
func (c *CursorState) Reset() <span class="cov8" title="1">{
        c.index = 0
}</span>

// HandleKeyMsg processes key messages for cursor navigation
// Returns true if the key was handled, false otherwise
func (c *CursorState) HandleKeyMsg(msg tea.KeyMsg, keyMap KeyMap) bool <span class="cov8" title="1">{
        switch </span>{
        case key.Matches(msg, keyMap.Up):<span class="cov8" title="1">
                c.MoveUp()
                return true</span>
        case key.Matches(msg, keyMap.Down):<span class="cov8" title="1">
                c.MoveDown()
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
)

// SessionListItem represents a session in the TUI list with Claude Squad styling
type SessionListItem struct {
        session SessionInfo
}

// NewSessionListItem creates a new session list item
func NewSessionListItem(session SessionInfo) SessionListItem <span class="cov8" title="1">{
        return SessionListItem{
                session: session,
        }
}</span>

// Title implements list.Item interface for sessions
func (s SessionListItem) Title() string <span class="cov8" title="1">{
        // Get status icon using Claude Squad styling
        statusIcon := s.formatStatusIcon(s.session.Status)
        
        // Format: [‚óè] agent-name (model)
        return fmt.Sprintf("%s %s %s", 
                statusIcon,
                s.session.AgentName,
                ClaudeSquadAccentStyle.Render(fmt.Sprintf("(%s)", s.session.Model)))
}</span>

// Description implements list.Item interface for sessions
func (s SessionListItem) Description() string <span class="cov8" title="1">{
        // Build description with status, diff stats, dev URL, and prompt
        var parts []string
        
        // Status with Claude Squad colors
        status := s.formatStatus(s.session.Status)
        parts = append(parts, status)
        
        // Git diff stats with Claude Squad green accent
        if s.session.Insertions &gt; 0 || s.session.Deletions &gt; 0 </span><span class="cov8" title="1">{
                diffStats := fmt.Sprintf("+%d/-%d", s.session.Insertions, s.session.Deletions)
                parts = append(parts, ClaudeSquadAccentStyle.Render(diffStats))
        }</span>
        
        // Dev server URL with Claude Squad accent
        <span class="cov8" title="1">if s.session.Port &gt; 0 </span><span class="cov8" title="1">{
                devURL := fmt.Sprintf("localhost:%d", s.session.Port)
                parts = append(parts, ClaudeSquadAccentStyle.Render(devURL))
        }</span>
        
        // Truncated prompt with muted styling
        <span class="cov8" title="1">prompt := s.session.Prompt
        if len(prompt) &gt; 50 </span><span class="cov8" title="1">{
                prompt = prompt[:47] + "..."
        }</span>
        <span class="cov8" title="1">if prompt != "" </span><span class="cov8" title="1">{
                parts = append(parts, ClaudeSquadMutedStyle.Render(prompt))
        }</span>
        
        <span class="cov8" title="1">return strings.Join(parts, " ‚îÇ ")</span>
}

// FilterValue implements list.Item interface for sessions
func (s SessionListItem) FilterValue() string <span class="cov8" title="1">{
        return s.session.AgentName + " " + s.session.Model + " " + s.session.Prompt
}</span>

// formatStatusIcon returns a styled status icon using Claude Squad colors
func (s SessionListItem) formatStatusIcon(status string) string <span class="cov8" title="1">{
        switch status </span>{
        case "attached":<span class="cov8" title="1">
                return ClaudeSquadAccentStyle.Render("‚óè")</span> // Claude Squad green
        case "running":<span class="cov8" title="1">
                return ClaudeSquadAccentStyle.Render("‚óè")</span> // Claude Squad green 
        case "ready":<span class="cov8" title="1">
                return ClaudeSquadAccentStyle.Render("‚óã")</span> // Claude Squad green outline
        case "inactive":<span class="cov8" title="1">
                return ClaudeSquadMutedStyle.Render("‚óã")</span>  // Muted gray
        default:<span class="cov8" title="1">
                return ClaudeSquadMutedStyle.Render("?")</span>
        }
}

// formatStatus returns a styled status string using Claude Squad colors
func (s SessionListItem) formatStatus(status string) string <span class="cov8" title="1">{
        switch status </span>{
        case "attached":<span class="cov0" title="0">
                return ClaudeSquadAccentStyle.Render("attached")</span>
        case "running":<span class="cov8" title="1">
                return ClaudeSquadAccentStyle.Render("running")</span>
        case "ready":<span class="cov8" title="1">
                return ClaudeSquadPrimaryStyle.Render("ready")</span>
        case "inactive":<span class="cov8" title="1">
                return ClaudeSquadMutedStyle.Render("inactive")</span>
        default:<span class="cov0" title="0">
                return ClaudeSquadMutedStyle.Render(status)</span>
        }
}

// ListModel wraps the bubbles list component with Claude Squad styling
type ListModel struct {
        list    list.Model
        width   int
        height  int
}

// NewListModel creates a new list model with Claude Squad styling
func NewListModel(width, height int) ListModel <span class="cov8" title="1">{
        // Create custom delegate for Claude Squad styling
        delegate := list.NewDefaultDelegate()
        delegate.Styles.SelectedTitle = ClaudeSquadSelectedStyle
        delegate.Styles.SelectedDesc = ClaudeSquadSelectedDescStyle
        delegate.Styles.NormalTitle = ClaudeSquadNormalTitleStyle
        delegate.Styles.NormalDesc = ClaudeSquadNormalDescStyle
        delegate.Styles.DimmedTitle = ClaudeSquadMutedStyle
        delegate.Styles.DimmedDesc = ClaudeSquadMutedStyle

        // Create list with custom delegate
        l := list.New([]list.Item{}, delegate, width, height)
        l.Title = "Agent Sessions"
        l.Styles.Title = ClaudeSquadHeaderStyle
        l.Styles.TitleBar = ClaudeSquadHeaderBarStyle
        
        // Customize the empty state message
        l.SetShowStatusBar(false) // Hide the status bar to prevent double messages
        l.SetShowPagination(false) // Hide pagination for cleaner look when few items
        
        return ListModel{
                list:   l,
                width:  width,
                height: height,
        }
}</span>

// LoadSessions loads session information and renders each row with agent name, status icon, diff stats, and dev URL
func (m *ListModel) LoadSessions(sessions []SessionInfo) <span class="cov8" title="1">{
        // Convert SessionInfo slice to list.Item slice
        items := make([]list.Item, len(sessions))
        for i, session := range sessions </span><span class="cov8" title="1">{
                items[i] = NewSessionListItem(session)
        }</span>
        
        // Update the list with new items
        <span class="cov8" title="1">m.list.SetItems(items)</span>
}

// SetSize updates the dimensions of the list
func (m *ListModel) SetSize(width, height int) <span class="cov0" title="0">{
        m.width = width
        m.height = height
        m.list.SetSize(width, height)
}</span>

// SelectedSession returns the currently selected session, if any
func (m ListModel) SelectedSession() *SessionInfo <span class="cov8" title="1">{
        if item := m.list.SelectedItem(); item != nil </span><span class="cov8" title="1">{
                if sessionItem, ok := item.(SessionListItem); ok </span><span class="cov8" title="1">{
                        return &amp;sessionItem.session
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Init implements tea.Model interface
func (m ListModel) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// Update implements tea.Model interface
func (m ListModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                // Handle additional key events here if needed
                switch msg.String() </span>{
                case "enter":<span class="cov0" title="0">
                        // Could emit a custom message for session selection
                        if selected := m.SelectedSession(); selected != nil </span><span class="cov0" title="0">{
                                // Return a command to handle session selection
                                return m, tea.Sequence(tea.Printf("Selected: %s", selected.Name))
                        }</span>
                }
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                // Update size when window changes
                m.SetSize(msg.Width, msg.Height-4)</span> // Account for header/footer
        }
        
        <span class="cov8" title="1">var cmd tea.Cmd
        listModel, cmd := m.list.Update(msg)
        m.list = listModel
        return m, cmd</span>
}

// View implements tea.Model interface
func (m ListModel) View() string <span class="cov0" title="0">{
        // Check if list is empty and provide custom empty state
        if len(m.list.Items()) == 0 </span><span class="cov0" title="0">{
                emptyMessage := ClaudeSquadMutedStyle.Render("No active agent sessions")
                headerView := ClaudeSquadHeaderStyle.Render("Agent Sessions")
                
                // Calculate padding to center the message
                maxWidth := m.width - 4 // Account for border padding
                padding := (maxWidth - len("No active agent sessions")) / 2
                if padding &lt; 0 </span><span class="cov0" title="0">{
                        padding = 0
                }</span>
                
                <span class="cov0" title="0">emptyView := fmt.Sprintf("%s\n\n%s%s", 
                        headerView,
                        strings.Repeat(" ", padding),
                        emptyMessage)
                
                return ClaudeSquadBorderStyle.Render(emptyView)</span>
        }
        
        <span class="cov0" title="0">return ClaudeSquadBorderStyle.Render(m.list.View())</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "github.com/charmbracelet/lipgloss"
)

// Claude Squad Color Palette
// Based on the design from uzi-site/index.html
var (
        // Primary Claude Squad colors
        ClaudeSquadPrimary = lipgloss.Color("#ffffff")    // White text
        ClaudeSquadAccent  = lipgloss.Color("#00ff9d")    // Signature green
        ClaudeSquadDark    = lipgloss.Color("#0a0a0a")    // Deep black background
        ClaudeSquadGray    = lipgloss.Color("#1a1a1a")    // Dark gray containers
        ClaudeSquadMuted   = lipgloss.Color("#6b7280")    // Muted gray for secondary text
        ClaudeSquadHover   = lipgloss.Color("#00e68a")    // Slightly darker green for hover
        
        // Legacy colors for backward compatibility
        PrimaryColor   = lipgloss.Color("#7C3AED")
        SecondaryColor = lipgloss.Color("#10B981")
        AccentColor    = lipgloss.Color("#F59E0B")
        ErrorColor     = lipgloss.Color("#EF4444")
        SuccessColor   = lipgloss.Color("#10B981")
        WarningColor   = lipgloss.Color("#F59E0B")
        MutedColor     = lipgloss.Color("#6B7280")
)

// Claude Squad Base Styles
var (
        // Core styling with Claude Squad theme
        ClaudeSquadBaseStyle = lipgloss.NewStyle().
                Foreground(ClaudeSquadPrimary).
                Background(ClaudeSquadDark)
        
        // Primary accent styling (Claude Squad green)
        ClaudeSquadAccentStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadAccent).
                Bold(true)
        
        // Primary text styling
        ClaudeSquadPrimaryStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadPrimary)
        
        // Muted text styling
        ClaudeSquadMutedStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadMuted)
        
        // Header styling
        ClaudeSquadHeaderStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadPrimary).
                Bold(true).
                MarginBottom(1)
        
        // Header bar styling
        ClaudeSquadHeaderBarStyle = ClaudeSquadBaseStyle.Copy().
                Background(ClaudeSquadGray)
        
        // Border styling with Claude Squad theme
        ClaudeSquadBorderStyle = ClaudeSquadBaseStyle.Copy().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(ClaudeSquadAccent).
                Padding(1)
        
        // Selected item styling (highlighted with Claude Squad green)
        ClaudeSquadSelectedStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadAccent).
                Bold(true)
        
        // Selected description styling
        ClaudeSquadSelectedDescStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadPrimary)
        
        // Normal title styling
        ClaudeSquadNormalTitleStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadPrimary)
        
        // Normal description styling
        ClaudeSquadNormalDescStyle = ClaudeSquadBaseStyle.Copy().
                Foreground(ClaudeSquadMuted)
)

// Legacy Base styles for backward compatibility
var (
        BaseStyle = lipgloss.NewStyle()
        
        // Header styles
        HeaderStyle = BaseStyle.Copy().
                Bold(true).
                Foreground(PrimaryColor).
                MarginBottom(1)
        
        // Content styles
        ContentStyle = BaseStyle.Copy().
                Padding(1, 2)
        
        // Status styles
        StatusReadyStyle = BaseStyle.Copy().
                Foreground(SuccessColor).
                Bold(true)
        
        StatusRunningStyle = BaseStyle.Copy().
                Foreground(WarningColor).
                Bold(true)
        
        StatusErrorStyle = BaseStyle.Copy().
                Foreground(ErrorColor).
                Bold(true)
        
        // Border styles
        BorderStyle = BaseStyle.Copy().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(MutedColor)
        
        // Selected item style
        SelectedItemStyle = BaseStyle.Copy().
                Foreground(PrimaryColor).
                Bold(true)
        
        // Help text style
        HelpStyle = BaseStyle.Copy().
                Foreground(MutedColor).
                Italic(true)
)

// Claude Squad utility functions

// FormatStatusWithClaudeSquad returns a styled status string using Claude Squad colors
func FormatStatusWithClaudeSquad(status string) string <span class="cov0" title="0">{
        switch status </span>{
        case "attached":<span class="cov0" title="0">
                return ClaudeSquadAccentStyle.Render("‚óè")</span>
        case "running":<span class="cov0" title="0">
                return ClaudeSquadAccentStyle.Render("‚óè")</span>
        case "ready":<span class="cov0" title="0">
                return ClaudeSquadPrimaryStyle.Render("‚óã")</span>
        case "inactive":<span class="cov0" title="0">
                return ClaudeSquadMutedStyle.Render("‚óã")</span>
        default:<span class="cov0" title="0">
                return ClaudeSquadMutedStyle.Render("?")</span>
        }
}

// ApplyClaudeSquadTheme applies Claude Squad theming to the given style
func ApplyClaudeSquadTheme(style lipgloss.Style) lipgloss.Style <span class="cov0" title="0">{
        return style.
                Foreground(ClaudeSquadPrimary).
                Background(ClaudeSquadDark)
}</span>

// ApplyTheme applies consistent theming to the given style (legacy)
func ApplyTheme(style lipgloss.Style) lipgloss.Style <span class="cov0" title="0">{
        // For backward compatibility, apply Claude Squad theme
        return ApplyClaudeSquadTheme(style)
}</span>

// FormatStatus returns a styled status string (legacy)
func FormatStatus(status string) string <span class="cov0" title="0">{
        // Use Claude Squad styling by default
        return FormatStatusWithClaudeSquad(status)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "fmt"
        "os/exec"
        "strconv"
        "strings"
        "time"
)

// TmuxSessionInfo represents information about a tmux session
type TmuxSessionInfo struct {
        Name        string    `json:"name"`
        Windows     int       `json:"windows"`
        Panes       int       `json:"panes"`
        Attached    bool      `json:"attached"`
        Created     time.Time `json:"created"`
        LastUsed    time.Time `json:"last_used"`
        WindowNames []string  `json:"window_names"`
        Activity    string    `json:"activity"` // "active", "inactive", "attached"
}

// TmuxDiscovery provides functionality to discover and analyze tmux sessions
type TmuxDiscovery struct {
        // Cache to avoid calling tmux ls too frequently
        lastUpdate time.Time
        sessions    map[string]TmuxSessionInfo
        cacheTime   time.Duration
}

// NewTmuxDiscovery creates a new tmux discovery helper
func NewTmuxDiscovery() *TmuxDiscovery <span class="cov8" title="1">{
        return &amp;TmuxDiscovery{
                sessions:  make(map[string]TmuxSessionInfo),
                cacheTime: 2 * time.Second, // Cache for 2 seconds to avoid excessive tmux calls
        }
}</span>

// GetAllSessions calls `tmux ls` and returns all tmux sessions
func (td *TmuxDiscovery) GetAllSessions() (map[string]TmuxSessionInfo, error) <span class="cov0" title="0">{
        // Check cache first
        if time.Since(td.lastUpdate) &lt; td.cacheTime &amp;&amp; len(td.sessions) &gt; 0 </span><span class="cov0" title="0">{
                return td.sessions, nil
        }</span>

        <span class="cov0" title="0">sessions, err := td.discoverTmuxSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update cache
        <span class="cov0" title="0">td.sessions = sessions
        td.lastUpdate = time.Now()

        return sessions, nil</span>
}

// GetUziSessions returns only tmux sessions that appear to be Uzi agent sessions
func (td *TmuxDiscovery) GetUziSessions() (map[string]TmuxSessionInfo, error) <span class="cov0" title="0">{
        allSessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">uziSessions := make(map[string]TmuxSessionInfo)
        for name, session := range allSessions </span><span class="cov0" title="0">{
                if td.isUziSession(name, session) </span><span class="cov0" title="0">{
                        uziSessions[name] = session
                }</span>
        }

        <span class="cov0" title="0">return uziSessions, nil</span>
}

// MapUziSessionsToTmux maps Uzi session names to their tmux session info
// This is useful for the TUI to highlight which sessions are attached/active
func (td *TmuxDiscovery) MapUziSessionsToTmux(uziSessions []SessionInfo) (map[string]TmuxSessionInfo, error) <span class="cov0" title="0">{
        tmuxSessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sessionMap := make(map[string]TmuxSessionInfo)
        
        for _, uziSession := range uziSessions </span><span class="cov0" title="0">{
                // Try to find corresponding tmux session
                if tmuxInfo, exists := tmuxSessions[uziSession.Name]; exists </span><span class="cov0" title="0">{
                        sessionMap[uziSession.Name] = tmuxInfo
                }</span> else<span class="cov0" title="0"> {
                        // Create a placeholder entry for missing tmux sessions
                        sessionMap[uziSession.Name] = TmuxSessionInfo{
                                Name:     uziSession.Name,
                                Attached: false,
                                Activity: "inactive",
                        }
                }</span>
        }

        <span class="cov0" title="0">return sessionMap, nil</span>
}

// IsSessionAttached returns true if the given session name is currently attached
func (td *TmuxDiscovery) IsSessionAttached(sessionName string) bool <span class="cov0" title="0">{
        sessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if session, exists := sessions[sessionName]; exists </span><span class="cov0" title="0">{
                return session.Attached
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

// GetSessionActivity returns the activity status of a session
func (td *TmuxDiscovery) GetSessionActivity(sessionName string) string <span class="cov0" title="0">{
        sessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">if session, exists := sessions[sessionName]; exists </span><span class="cov0" title="0">{
                return session.Activity
        }</span>
        
        <span class="cov0" title="0">return "inactive"</span>
}

// discoverTmuxSessions calls `tmux ls` and parses the output
func (td *TmuxDiscovery) discoverTmuxSessions() (map[string]TmuxSessionInfo, error) <span class="cov0" title="0">{
        // Call tmux list-sessions with detailed format
        cmd := exec.Command("tmux", "list-sessions", "-F", "#{session_name}|#{session_windows}|#{?session_attached,1,0}|#{session_created}|#{session_activity}")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If tmux command fails, it might be because no sessions exist
                // Return empty map instead of error
                return make(map[string]TmuxSessionInfo), nil
        }</span>

        <span class="cov0" title="0">sessions := make(map[string]TmuxSessionInfo)
        lines := strings.Split(strings.TrimSpace(string(output)), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">session, err := td.parseSessionLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but don't fail completely for one bad line
                        continue</span>
                }

                // Get window information for this session
                <span class="cov0" title="0">windowNames, paneCount, err := td.getSessionWindows(session.Name)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue without window info if we can't get it
                        windowNames = []string{}
                        paneCount = 0
                }</span>

                <span class="cov0" title="0">session.WindowNames = windowNames
                session.Panes = paneCount
                sessions[session.Name] = session</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

// parseSessionLine parses a single line from tmux list-sessions output
func (td *TmuxDiscovery) parseSessionLine(line string) (TmuxSessionInfo, error) <span class="cov0" title="0">{
        // Format: name|windows|attached|created|activity
        parts := strings.Split(line, "|")
        if len(parts) != 5 </span><span class="cov0" title="0">{
                return TmuxSessionInfo{}, fmt.Errorf("unexpected tmux output format: %s", line)
        }</span>

        <span class="cov0" title="0">name := parts[0]
        windows, _ := strconv.Atoi(parts[1])
        attached := parts[2] == "1"
        createdUnix, _ := strconv.ParseInt(parts[3], 10, 64)
        activityUnix, _ := strconv.ParseInt(parts[4], 10, 64)

        created := time.Unix(createdUnix, 0)
        lastUsed := time.Unix(activityUnix, 0)

        activity := "inactive"
        if attached </span><span class="cov0" title="0">{
                activity = "attached"
        }</span> else<span class="cov0" title="0"> if time.Since(lastUsed) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                activity = "active"
        }</span>

        <span class="cov0" title="0">return TmuxSessionInfo{
                Name:     name,
                Windows:  windows,
                Attached: attached,
                Created:  created,
                LastUsed: lastUsed,
                Activity: activity,
        }, nil</span>
}

// getSessionWindows gets window names and pane count for a session
func (td *TmuxDiscovery) getSessionWindows(sessionName string) ([]string, int, error) <span class="cov0" title="0">{
        // Get window information
        windowCmd := exec.Command("tmux", "list-windows", "-t", sessionName, "-F", "#{window_name}")
        windowOutput, err := windowCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">windowNames := strings.Split(strings.TrimSpace(string(windowOutput)), "\n")
        if len(windowNames) == 1 &amp;&amp; windowNames[0] == "" </span><span class="cov0" title="0">{
                windowNames = []string{}
        }</span>

        // Get pane count
        <span class="cov0" title="0">paneCmd := exec.Command("tmux", "list-panes", "-t", sessionName, "-a", "-F", "#{pane_id}")
        paneOutput, err := paneCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return windowNames, 0, err
        }</span>

        <span class="cov0" title="0">paneLines := strings.Split(strings.TrimSpace(string(paneOutput)), "\n")
        paneCount := len(paneLines)
        if len(paneLines) == 1 &amp;&amp; paneLines[0] == "" </span><span class="cov0" title="0">{
                paneCount = 0
        }</span>

        <span class="cov0" title="0">return windowNames, paneCount, nil</span>
}

// isUziSession determines if a tmux session appears to be a Uzi agent session
func (td *TmuxDiscovery) isUziSession(sessionName string, session TmuxSessionInfo) bool <span class="cov0" title="0">{
        // Check if session name follows Uzi pattern: agent-projectDir-gitHash-agentName
        if strings.HasPrefix(sessionName, "agent-") </span><span class="cov0" title="0">{
                parts := strings.Split(sessionName, "-")
                if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Also check if session has windows that suggest it's a Uzi session
        <span class="cov0" title="0">for _, windowName := range session.WindowNames </span><span class="cov0" title="0">{
                if windowName == "agent" || windowName == "uzi-dev" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// GetSessionStatus returns a more detailed status for a session
func (td *TmuxDiscovery) GetSessionStatus(sessionName string) (string, error) <span class="cov0" title="0">{
        sessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown", err
        }</span>

        <span class="cov0" title="0">session, exists := sessions[sessionName]
        if !exists </span><span class="cov0" title="0">{
                return "not_found", nil
        }</span>

        <span class="cov0" title="0">if session.Attached </span><span class="cov0" title="0">{
                return "attached", nil
        }</span>

        // Check if session has any activity in agent window
        <span class="cov0" title="0">if td.hasAgentWindow(sessionName) </span><span class="cov0" title="0">{
                content, err := td.getAgentWindowContent(sessionName)
                if err != nil </span><span class="cov0" title="0">{
                        return "ready", nil
                }</span>

                // Check for running indicators in the agent pane
                <span class="cov0" title="0">if strings.Contains(content, "esc to interrupt") || 
                   strings.Contains(content, "Thinking") || 
                   strings.Contains(content, "Working") </span><span class="cov0" title="0">{
                        return "running", nil
                }</span>
        }

        <span class="cov0" title="0">return "ready", nil</span>
}

// hasAgentWindow checks if session has an "agent" window
func (td *TmuxDiscovery) hasAgentWindow(sessionName string) bool <span class="cov0" title="0">{
        sessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">session, exists := sessions[sessionName]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, windowName := range session.WindowNames </span><span class="cov0" title="0">{
                if windowName == "agent" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// getAgentWindowContent gets the content of the agent window/pane
func (td *TmuxDiscovery) getAgentWindowContent(sessionName string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("tmux", "capture-pane", "-t", sessionName+":agent", "-p")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(output), nil</span>
}

// RefreshCache forces a refresh of the tmux session cache
func (td *TmuxDiscovery) RefreshCache() <span class="cov0" title="0">{
        td.lastUpdate = time.Time{}
}</span>

// FormatSessionActivity returns a styled string for session activity
func (td *TmuxDiscovery) FormatSessionActivity(activity string) string <span class="cov0" title="0">{
        switch activity </span>{
        case "attached":<span class="cov0" title="0">
                return "üîó"</span>  // Link symbol for attached
        case "active":<span class="cov0" title="0">
                return "‚óè"</span>   // Dot for active
        case "inactive":<span class="cov0" title="0">
                return "‚óã"</span>   // Empty circle for inactive
        default:<span class="cov0" title="0">
                return "?"</span>   // Unknown
        }
}

// GetAttachedSessionCount returns the number of currently attached sessions
func (td *TmuxDiscovery) GetAttachedSessionCount() (int, error) <span class="cov0" title="0">{
        sessions, err := td.GetAllSessions()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">count := 0
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.Attached </span><span class="cov0" title="0">{
                        count++
                }</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// ListSessionsByActivity returns sessions grouped by activity level
func (td *TmuxDiscovery) ListSessionsByActivity() (map[string][]TmuxSessionInfo, error) <span class="cov0" title="0">{
        sessions, err := td.GetUziSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">grouped := map[string][]TmuxSessionInfo{
                "attached": {},
                "active":   {},
                "inactive": {},
        }

        for _, session := range sessions </span><span class="cov0" title="0">{
                grouped[session.Activity] = append(grouped[session.Activity], session)
        }</span>

        <span class="cov0" title="0">return grouped, nil</span>
}

// GetSessionMatchScore returns a score indicating how well a tmux session matches a Uzi session
// This can be used for fuzzy matching when session names don't exactly match
func (td *TmuxDiscovery) GetSessionMatchScore(tmuxSessionName, uziSessionName string) int <span class="cov0" title="0">{
        if tmuxSessionName == uziSessionName </span><span class="cov0" title="0">{
                return 100 // Perfect match
        }</span>

        // Extract agent name from both and compare
        <span class="cov0" title="0">tmuxAgent := extractAgentNameFromTmux(tmuxSessionName)
        uziAgent := extractAgentNameFromTmux(uziSessionName)
        
        if tmuxAgent == uziAgent </span><span class="cov0" title="0">{
                return 80 // Good match on agent name
        }</span>

        // Check if one contains the other
        <span class="cov0" title="0">if strings.Contains(tmuxSessionName, uziAgent) || strings.Contains(uziSessionName, tmuxAgent) </span><span class="cov0" title="0">{
                return 60 // Partial match
        }</span>

        <span class="cov0" title="0">return 0</span> // No match
}

// Helper function to extract agent name (reuse from existing code)
func extractAgentNameFromTmux(sessionName string) string <span class="cov0" title="0">{
        parts := strings.Split(sessionName, "-")
        if len(parts) &gt;= 4 &amp;&amp; parts[0] == "agent" </span><span class="cov0" title="0">{
                return strings.Join(parts[3:], "-")
        }</span>
        <span class="cov0" title="0">return sessionName</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) Subtrace, Inc.
// SPDX-License-Identifier: BSD-3-Clause

package tui

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "os/exec"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/devflowinc/uzi/pkg/state"
)

// SessionInfo contains displayable information about a session
type SessionInfo struct {
        Name        string `json:"name"`
        AgentName   string `json:"agent_name"`
        Model       string `json:"model"`
        Status      string `json:"status"`
        Prompt      string `json:"prompt"`
        Insertions  int    `json:"insertions"`
        Deletions   int    `json:"deletions"`
        WorktreePath string `json:"worktree_path"`
        Port        int    `json:"port,omitempty"`
}

// UziInterface defines the interface for interacting with Uzi core functionality
type UziInterface interface {
        // GetSessions returns a list of session information
        GetSessions() ([]SessionInfo, error)
        
        // GetSessionState returns the state for a specific session
        GetSessionState(sessionName string) (*state.AgentState, error)
        
        // GetSessionStatus returns the current status of a session
        GetSessionStatus(sessionName string) (string, error)
        
        // AttachToSession attaches to an existing session
        AttachToSession(sessionName string) error
        
        // KillSession terminates a session
        KillSession(sessionName string) error
        
        // RefreshSessions refreshes the session list
        RefreshSessions() error
        
        // RunPrompt creates a new agent session
        RunPrompt(agents string, prompt string) error
        
        // RunBroadcast sends a message to all active sessions
        RunBroadcast(message string) error
        
        // RunCommand executes a command in all sessions
        RunCommand(command string) error
}

// ProxyConfig defines configuration for the UziCLI proxy
type ProxyConfig struct {
        Timeout     time.Duration
        Retries     int
        LogLevel    string
        EnableCache bool
}

// DefaultProxyConfig returns sensible defaults for the proxy
func DefaultProxyConfig() ProxyConfig <span class="cov8" title="1">{
        return ProxyConfig{
                Timeout:     30 * time.Second,
                Retries:     2,
                LogLevel:    "info",
                EnableCache: false,
        }
}</span>

// UziCLI implements UziInterface by providing a consistent proxy layer
// All operations go through this proxy for unified error handling, logging, and debugging
type UziCLI struct {
        stateManager  *state.StateManager
        tmuxDiscovery *TmuxDiscovery
        config        ProxyConfig
}

// NewUziCLI creates a new UziCLI implementation with default configuration
func NewUziCLI() *UziCLI <span class="cov8" title="1">{
        return NewUziCLIWithConfig(DefaultProxyConfig())
}</span>

// NewUziCLIWithConfig creates a new UziCLI implementation with custom configuration
func NewUziCLIWithConfig(config ProxyConfig) *UziCLI <span class="cov8" title="1">{
        return &amp;UziCLI{
                stateManager:  state.NewStateManager(),
                tmuxDiscovery: NewTmuxDiscovery(),
                config:        config,
        }
}</span>

// Core proxy infrastructure methods

// executeCommand runs a command with consistent error handling and logging
func (c *UziCLI) executeCommand(name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        return c.executeCommandWithTimeout(c.config.Timeout, name, args...)
}</span>

// executeCommandWithTimeout runs a command with a custom timeout
func (c *UziCLI) executeCommandWithTimeout(timeout time.Duration, name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        start := time.Now()
        var lastErr error

        for attempt := 0; attempt &lt;= c.config.Retries; attempt++ </span><span class="cov8" title="1">{
                cmd := exec.Command(name, args...)

                // Set up stdout and stderr capture
                var stdout, stderr bytes.Buffer
                cmd.Stdout = &amp;stdout
                cmd.Stderr = &amp;stderr

                // Create a channel to handle timeout
                done := make(chan error, 1)
                go func() </span><span class="cov8" title="1">{
                        done &lt;- cmd.Run()
                }</span>()

                <span class="cov8" title="1">select </span>{
                case err := &lt;-done:<span class="cov8" title="1">
                        duration := time.Since(start)
                        if err != nil </span><span class="cov8" title="1">{
                                lastErr = fmt.Errorf("command failed (attempt %d/%d): %w - stderr: %s", 
                                        attempt+1, c.config.Retries+1, err, stderr.String())
                                c.logOperation(fmt.Sprintf("%s %v", name, args), duration, lastErr)

                                // Don't retry if it's the last attempt
                                if attempt == c.config.Retries </span><span class="cov8" title="1">{
                                        return nil, c.wrapError(fmt.Sprintf("%s %v", name, args), lastErr)
                                }</span>

                                // Brief delay before retry
                                <span class="cov8" title="1">time.Sleep(500 * time.Millisecond)
                                continue</span>
                        }

                        // Success
                        <span class="cov0" title="0">c.logOperation(fmt.Sprintf("%s %v", name, args), duration, nil)
                        return stdout.Bytes(), nil</span>

                case &lt;-time.After(timeout):<span class="cov0" title="0">
                        cmd.Process.Kill()
                        lastErr = fmt.Errorf("command timed out after %v", timeout)
                        c.logOperation(fmt.Sprintf("%s %v", name, args), timeout, lastErr)

                        if attempt == c.config.Retries </span><span class="cov0" title="0">{
                                return nil, c.wrapError(fmt.Sprintf("%s %v", name, args), lastErr)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, c.wrapError(fmt.Sprintf("%s %v", name, args), lastErr)</span>
}

// wrapError provides consistent error wrapping with proxy context
func (c *UziCLI) wrapError(operation string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("uzi_proxy: %s: %w", operation, err)</span>
}

// logOperation logs command execution details based on configuration
func (c *UziCLI) logOperation(operation string, duration time.Duration, err error) <span class="cov8" title="1">{
        if c.config.LogLevel == "debug" || (c.config.LogLevel == "info" &amp;&amp; err != nil) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("[UziCLI] %s failed in %v: %v", operation, duration, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[UziCLI] %s completed in %v", operation, duration)
                }</span>
        }
}

// GetSessions implements UziInterface using the proxy pattern
// This shells out to `uzi ls --json` for consistent behavior
func (c *UziCLI) GetSessions() ([]SessionInfo, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ c.logOperation("GetSessions", time.Since(start), nil) }</span>()

        // Shell out to uzi ls --json (use ./uzi for testing to get current binary)
        <span class="cov8" title="1">output, err := c.executeCommand("./uzi", "ls", "--json")
        if err != nil </span><span class="cov8" title="1">{
                return nil, c.wrapError("GetSessions", err)
        }</span>

        // Parse JSON response
        <span class="cov0" title="0">var sessions []SessionInfo
        if err := json.Unmarshal(output, &amp;sessions); err != nil </span><span class="cov0" title="0">{
                return nil, c.wrapError("GetSessions", fmt.Errorf("failed to parse JSON: %w", err))
        }</span>

        <span class="cov0" title="0">return sessions, nil</span>
}

// GetSessionsLegacy implements the legacy behavior by reading state.json directly
// This method is kept for fallback and testing purposes
func (c *UziCLI) GetSessionsLegacy() ([]SessionInfo, error) <span class="cov0" title="0">{
        if c.stateManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("state manager not initialized")
        }</span>

        // Get active sessions
        <span class="cov0" title="0">activeSessions, err := c.stateManager.GetActiveSessionsForRepo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active sessions: %w", err)
        }</span>

        // Load state file to get detailed information
        <span class="cov0" title="0">states := make(map[string]state.AgentState)
        if data, err := os.ReadFile(c.stateManager.GetStatePath()); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return []SessionInfo{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read state file: %w", err)</span>
        } else<span class="cov0" title="0"> {
                if err := json.Unmarshal(data, &amp;states); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse state file: %w", err)
                }</span>
        }

        // Build session info list
        <span class="cov0" title="0">var sessions []SessionInfo
        for _, sessionName := range activeSessions </span><span class="cov0" title="0">{
                state, ok := states[sessionName]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract agent name from session name
                <span class="cov0" title="0">agentName := extractAgentName(sessionName)
                
                // Get session status
                status := c.getAgentStatus(sessionName)
                
                // Get git diff stats
                insertions, deletions := c.getGitDiffTotals(sessionName, &amp;state)

                sessionInfo := SessionInfo{
                        Name:         sessionName,
                        AgentName:    agentName,
                        Model:        state.Model,
                        Status:       status,
                        Prompt:       state.Prompt,
                        Insertions:   insertions,
                        Deletions:    deletions,
                        WorktreePath: state.WorktreePath,
                        Port:         state.Port,
                }
                sessions = append(sessions, sessionInfo)</span>
        }

        // Sort sessions by port for stable ordering
        // Sessions with port 0 (no dev server) will be sorted first
        <span class="cov0" title="0">sort.Slice(sessions, func(i, j int) bool </span><span class="cov0" title="0">{
                return sessions[i].Port &lt; sessions[j].Port
        }</span>)

        <span class="cov0" title="0">return sessions, nil</span>
}

// GetSessionState implements UziInterface
func (c *UziCLI) GetSessionState(sessionName string) (*state.AgentState, error) <span class="cov0" title="0">{
        if c.stateManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("state manager not initialized")
        }</span>

        // Load state file
        <span class="cov0" title="0">states := make(map[string]state.AgentState)
        data, err := os.ReadFile(c.stateManager.GetStatePath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read state file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;states); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse state file: %w", err)
        }</span>

        <span class="cov0" title="0">state, exists := states[sessionName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %s", sessionName)
        }</span>

        <span class="cov0" title="0">return &amp;state, nil</span>
}

// GetSessionStatus implements UziInterface
func (c *UziCLI) GetSessionStatus(sessionName string) (string, error) <span class="cov0" title="0">{
        return c.getAgentStatus(sessionName), nil
}</span>

// AttachToSession implements UziInterface by executing tmux attach
// Note: This is one case where we don't use executeCommand since it needs direct terminal access
func (c *UziCLI) AttachToSession(sessionName string) error <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{ c.logOperation("AttachToSession", time.Since(start), nil) }</span>()

        <span class="cov0" title="0">cmd := exec.Command("tmux", "attach-session", "-t", sessionName)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return c.wrapError("AttachToSession", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// KillSession implements UziInterface using the proxy pattern
func (c *UziCLI) KillSession(sessionName string) error <span class="cov8" title="1">{
        // Extract agent name from session name
        agentName := extractAgentName(sessionName)
        _, err := c.executeCommand("./uzi", "kill", agentName)
        if err != nil </span><span class="cov8" title="1">{
                return c.wrapError("KillSession", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RefreshSessions implements UziInterface (no-op as data is read fresh each time)
func (c *UziCLI) RefreshSessions() error <span class="cov8" title="1">{
        // No caching in this implementation, so nothing to refresh
        c.logOperation("RefreshSessions", 0, nil)
        return nil
}</span>

// RunPrompt implements UziInterface using the proxy pattern
func (c *UziCLI) RunPrompt(agents string, prompt string) error <span class="cov8" title="1">{
        _, err := c.executeCommand("./uzi", "prompt", "--agents", agents, prompt)
        if err != nil </span><span class="cov8" title="1">{
                return c.wrapError("RunPrompt", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RunBroadcast implements UziInterface using the proxy pattern
func (c *UziCLI) RunBroadcast(message string) error <span class="cov8" title="1">{
        _, err := c.executeCommand("./uzi", "broadcast", message)
        if err != nil </span><span class="cov8" title="1">{
                return c.wrapError("RunBroadcast", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RunCommand implements UziInterface using the proxy pattern
func (c *UziCLI) RunCommand(command string) error <span class="cov8" title="1">{
        _, err := c.executeCommand("./uzi", "run", command)
        if err != nil </span><span class="cov8" title="1">{
                return c.wrapError("RunCommand", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Helper functions (these replicate logic from cmd/ls/ls.go for now)

// extractAgentName extracts the agent name from a session name
// Session format: agent-projectDir-gitHash-agentName
func extractAgentName(sessionName string) string <span class="cov8" title="1">{
        parts := strings.Split(sessionName, "-")
        if len(parts) &gt;= 4 &amp;&amp; parts[0] == "agent" </span><span class="cov8" title="1">{
                return strings.Join(parts[3:], "-")
        }</span>
        <span class="cov8" title="1">return sessionName</span>
}

// getAgentStatus determines the current status of an agent session
func (c *UziCLI) getAgentStatus(sessionName string) string <span class="cov0" title="0">{
        content, err := c.getPaneContent(sessionName)
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">if strings.Contains(content, "esc to interrupt") || strings.Contains(content, "Thinking") </span><span class="cov0" title="0">{
                return "running"
        }</span>
        <span class="cov0" title="0">return "ready"</span>
}

// getPaneContent gets the content of a tmux pane
func (c *UziCLI) getPaneContent(sessionName string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("tmux", "capture-pane", "-t", sessionName+":agent", "-p")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(output), nil</span>
}

// getGitDiffTotals gets the insertion/deletion counts for a session
func (c *UziCLI) getGitDiffTotals(sessionName string, sessionState *state.AgentState) (int, int) <span class="cov0" title="0">{
        if sessionState.WorktreePath == "" </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov0" title="0">shellCmdString := "git add -A . &amp;&amp; git diff --cached --shortstat HEAD &amp;&amp; git reset HEAD &gt; /dev/null"
        cmd := exec.Command("sh", "-c", shellCmdString)
        cmd.Dir = sessionState.WorktreePath

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov0" title="0">insertions := 0
        deletions := 0

        insRe := regexp.MustCompile(`(\d+) insertion(?:s)?\(\+\)`)
        delRe := regexp.MustCompile(`(\d+) deletion(?:s)?\(\-\)`)

        if m := insRe.FindStringSubmatch(string(output)); len(m) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Sscanf(m[1], "%d", &amp;insertions)
        }</span>
        <span class="cov0" title="0">if m := delRe.FindStringSubmatch(string(output)); len(m) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Sscanf(m[1], "%d", &amp;deletions)
        }</span>

        <span class="cov0" title="0">return insertions, deletions</span>
}

// Enhanced methods using tmux discovery

// GetSessionsWithTmuxInfo returns sessions enhanced with tmux attachment information
func (c *UziCLI) GetSessionsWithTmuxInfo() ([]SessionInfo, map[string]TmuxSessionInfo, error) <span class="cov0" title="0">{
        sessions, err := c.GetSessions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Get tmux session mapping
        <span class="cov0" title="0">tmuxMapping, err := c.tmuxDiscovery.MapUziSessionsToTmux(sessions)
        if err != nil </span><span class="cov0" title="0">{
                return sessions, nil, err // Return sessions even if tmux mapping fails
        }</span>

        // Update session status with tmux information where available
        <span class="cov0" title="0">for i := range sessions </span><span class="cov0" title="0">{
                if tmuxInfo, exists := tmuxMapping[sessions[i].Name]; exists </span><span class="cov0" title="0">{
                        // Enhance status with tmux information
                        if tmuxInfo.Attached </span><span class="cov0" title="0">{
                                sessions[i].Status = "attached"
                        }</span> else<span class="cov0" title="0"> if sessions[i].Status == "ready" </span><span class="cov0" title="0">{
                                // Only update if current status is generic "ready"
                                if tmuxStatus, err := c.tmuxDiscovery.GetSessionStatus(sessions[i].Name); err == nil </span><span class="cov0" title="0">{
                                        sessions[i].Status = tmuxStatus
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return sessions, tmuxMapping, nil</span>
}

// IsSessionAttached returns true if a session is currently attached in tmux
func (c *UziCLI) IsSessionAttached(sessionName string) bool <span class="cov0" title="0">{
        return c.tmuxDiscovery.IsSessionAttached(sessionName)
}</span>

// GetSessionActivity returns the activity level of a session
func (c *UziCLI) GetSessionActivity(sessionName string) string <span class="cov0" title="0">{
        return c.tmuxDiscovery.GetSessionActivity(sessionName)
}</span>

// GetAttachedSessionCount returns the number of currently attached sessions
func (c *UziCLI) GetAttachedSessionCount() (int, error) <span class="cov0" title="0">{
        return c.tmuxDiscovery.GetAttachedSessionCount()
}</span>

// RefreshTmuxCache forces a refresh of the tmux session cache
func (c *UziCLI) RefreshTmuxCache() <span class="cov0" title="0">{
        c.tmuxDiscovery.RefreshCache()
}</span>

// GetTmuxSessionsByActivity returns Uzi sessions grouped by their tmux activity level
func (c *UziCLI) GetTmuxSessionsByActivity() (map[string][]TmuxSessionInfo, error) <span class="cov0" title="0">{
        return c.tmuxDiscovery.ListSessionsByActivity()
}</span>

// FormatSessionActivity returns a styled activity indicator for the TUI
func (c *UziCLI) FormatSessionActivity(sessionName string) string <span class="cov0" title="0">{
        activity := c.tmuxDiscovery.GetSessionActivity(sessionName)
        return c.tmuxDiscovery.FormatSessionActivity(activity)
}</span>

// Legacy UziClient for backward compatibility
// TODO: Remove this once TUI is fully migrated to use UziCLI
type UziClient struct {
        stateManager *state.StateManager
}

// NewUziClient creates a new Uzi client for TUI operations (legacy)
func NewUziClient() *UziClient <span class="cov0" title="0">{
        return &amp;UziClient{
                stateManager: state.NewStateManager(),
        }
}</span>

// GetActiveSessions implements legacy interface
func (c *UziClient) GetActiveSessions() ([]string, error) <span class="cov0" title="0">{
        if c.stateManager == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return c.stateManager.GetActiveSessionsForRepo()</span>
}

// Stub implementations for compilation compatibility

func (c *UziClient) GetSessionState(sessionName string) (*state.AgentState, error) <span class="cov0" title="0">{
        // Stub: will be replaced by UziCLI implementation
        _ = sessionName
        return nil, fmt.Errorf("not implemented - use UziCLI instead")
}</span>

func (c *UziClient) GetSessionStatus(sessionName string) (string, error) <span class="cov0" title="0">{
        // Stub: will be replaced by UziCLI implementation
        _ = sessionName
        return "unknown", nil
}</span>

func (c *UziClient) AttachToSession(sessionName string) error <span class="cov0" title="0">{
        // Stub: will be replaced by UziCLI implementation
        _ = sessionName
        return fmt.Errorf("not implemented - use UziCLI instead")
}</span>

func (c *UziClient) KillSession(sessionName string) error <span class="cov0" title="0">{
        // Stub: will be replaced by UziCLI implementation
        _ = sessionName
        return fmt.Errorf("not implemented - use UziCLI instead")
}</span>

func (c *UziClient) RefreshSessions() error <span class="cov0" title="0">{
        // Stub: will be replaced by UziCLI implementation
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
